import os
import sys
import shutil
import docker

class AppContainerizationUbuntu:

    # forceNew forces both image and container to be created even if they already exist
    def __init__(self,appName, forceNew=False, userName="developer", gui=True):
        self.local_absPath_currentDir = os.path.dirname(os.path.realpath(__file__))
        self.local_relPath_packageFolder = "packages/ubuntu"
        self.local_relPath_repoConfigFolder = "RepoConfigFiles"
        self.local_relPath_SourcesFile = self.local_relPath_repoConfigFolder + "/DEB_temprepository.list"
        self.container_repoFolder = "/var/tempRepository"
        self.container_tmpSourceConfigPath = "/etc/apt/sources.list.d/tempRepo.list"
        self.local_relPath_homeFolders = "DockerHomeFolders"
        self.local_relPath_homeFolder = self.local_relPath_homeFolders + "/UserHomeFolder_" + appName
        self.local_relPath_packageArchive = self.local_relPath_packageFolder + "/" + appName + "Packages.tar"
        self.local_relPath_DockerfileFolder = "DockerfileFolder"
        self.local_relPath_DockerfilePath = self.local_relPath_DockerfileFolder + "/Dockerfile"
        self.appName = appName
        self.imageName = "img_" + appName
        self.containerName = "container_" + appName
        self.forceNew=forceNew
        self.userName=userName
        self.gui = gui
        self.checkFolderExistence()
        self.createDockerIgnoreFile()
        self.dockerClient = docker.from_env()

    def checkFolderExistence(self):
        if not os.path.isdir(self.local_relPath_repoConfigFolder):
            sys.exit("ERROR: Folder for repository configuration files not found (looking for %s)" % self.local_relPath_repoConfigFolder)
        if not os.path.isdir(self.local_relPath_packageFolder):
            sys.exit("ERROR: No Packages found for ubuntu (looking for %s)" % self.local_relPath_packageFolder)
        if not os.path.isdir(self.local_relPath_homeFolders):
            os.mkdir(self.local_relPath_homeFolders)
        if not os.path.isdir(self.local_relPath_DockerfileFolder):
            os.mkdir(self.local_relPath_DockerfileFolder)

    def createDockerIgnoreFile(self):
        if os.path.exists(".dockerignore"):
            os.remove(".dockerignore")
        with open(".dockerignore", "a") as dockerignore:
            dockerignore.write("#This .dockerignore file was automatically generated by ContainerManagement.py\n")
            for line in os.listdir('.'):
                if not (line == "packages"\
                        or line == ".dockerignore"\
                        or line == self.local_relPath_DockerfileFolder\
                        or line == self.local_relPath_repoConfigFolder
                        or line == self.local_relPath_homeFolders):
                    dockerignore.write(line + "\n")


    def runApplication(self):
        image = self.getImage()
        self.runContainer(image)

    def runContainer(self, image):
        print "\n=== Run Container"

        if not os.path.isdir(self.local_relPath_homeFolder):
            os.mkdir(self.local_relPath_homeFolder)
        elif self.forceNew:
            print "forceNew was set to True: Existing folder for persistent home directory \"%s\" will be replaced!" % self.local_relPath_homeFolder
            shutil.rmtree(self.local_relPath_homeFolder)
            os.mkdir(self.local_relPath_homeFolder)
        else:
            print "Using existing folder \"%s\" as persistent home directory" % self.local_relPath_homeFolder

        local_absPath_DockerHomeFolder = self.local_absPath_currentDir+'/'+self.local_relPath_homeFolder
        volumeDict = {
            '/tmp/.X11-unix':
                {'bind': '/tmp/.X11-unix',  'mode': 'rw'},
            '/dev/shm':
                {'bind': '/dev/shm',        'mode': 'rw'},
            local_absPath_DockerHomeFolder:
                {'bind': '/home/developer', 'mode': 'rw'}
        }
        return self.dockerClient.containers.run(image,
                                                name=self.containerName,
                                                stdin_open=True,
                                                tty=True,
                                                remove=True,
                                                network_mode="host",
                                                devices=["/dev/snd"],
                                                environment=["DISPLAY=unix"+os.environ['DISPLAY']],
                                                volumes=volumeDict)

    def getImage(self):
        print "\n=== Image retrieval"
        # Check if image already exists
        try:
            image = self.dockerClient.images.get(self.imageName)
            if self.forceNew:
                print "New Creation of image \"" + self.imageName + "\" was forced. Proceeding to build Image."
                self.dockerClient.images.remove(self.imageName)
                image = self.createImage()
            else:
                print "Image \"" + self.imageName + "\" already exists. Proceeding with existing Image."
        except docker.errors.NotFound:
            print "Image \"" + self.imageName + "\" does not exist yet. Proceeding to build Image."
            image = self.createImage()
        return image

    def createImage(self):
        if not os.path.exists(self.local_relPath_packageArchive):
            sys.exit("No package folder exists for application \"" + self.appName + "\"")
        if os.path.exists(self.local_relPath_DockerfilePath):
            os.remove(self.local_relPath_DockerfilePath)

        self.createDockerfile()
        '''
        client = docker.APIClient(base_url='unix://var/run/docker.sock')
        for line in client.build(path=self.local_absPath_currentDir,
                                 tag=self.imageName,
                                 dockerfile= self.local_relPath_DockerfilePath):
            print line
        '''
        image = self.dockerClient.images.build(path=self.local_absPath_currentDir,
                                               tag=self.imageName,
                                               dockerfile= self.local_relPath_DockerfilePath,
                                               rm=True)

        os.remove(self.local_relPath_DockerfilePath)
        return image

    def createDockerfile(self):
        continueRUN = " && \\\n"
        dockerfileString = ""
        if self.gui:
            dockerfileString += "FROM remmers/ubuntubase-gui\n"
        else:
            dockerfileString += "FROM ubuntu:latest\n"

        dockerfileString += "\n" + self.getDockerfileUserPart() + "\n"

        dockerfileString += "ADD " + self.local_relPath_packageArchive + " " + self.container_repoFolder + "\n"

        dockerfileString += "RUN\tDEBIAN_FRONTEND=noninteractive apt-get update -qqy --no-install-recommends" + continueRUN
        dockerfileString += "\tDEBIAN_FRONTEND=noninteractive apt-get install dpkg-dev -qqy --no-install-recommends" + continueRUN
        dockerfileString += "\tcd " + self.container_repoFolder + " && dpkg-scanpackages . /dev/null | gzip -9c > Packages.gz" + continueRUN
        dockerfileString += "\techo \"deb file://" + self.container_repoFolder + " ./\" >> " + self.container_tmpSourceConfigPath + continueRUN
        dockerfileString += "\tDEBIAN_FRONTEND=noninteractive apt-get update -qq -o Dir::Etc::sourcelist=\"" + self.container_tmpSourceConfigPath + "\"" + continueRUN
        dockerfileString += "\tDEBIAN_FRONTEND=noninteractive apt-get install " + self.appName + " -qqy --allow-unauthenticated" + continueRUN
        dockerfileString += "\trm " + self.container_tmpSourceConfigPath + continueRUN
        dockerfileString += "\tDEBIAN_FRONTEND=noninteractive apt-get purge dpkg-dev -qqy" + continueRUN
        dockerfileString += "\tDEBIAN_FRONTEND=noninteractive apt-get autoremove -qqy" + continueRUN
        dockerfileString += "\tDEBIAN_FRONTEND=noninteractive apt-get clean -qqy" + continueRUN
        dockerfileString += "\trm -rf /var/lib/apt/lists/*\n"

        dockerfileString +="\nUSER " + self.userName + "\n"
        dockerfileString +="CMD /usr/bin/" + self.appName

        with open(self.local_relPath_DockerfilePath, "a") as dockerfile:
            dockerfile.write(dockerfileString)

    def getDockerfileUserPart(self):
        continueRUN = " && \\\n"
        dockerfileUserPart  = "# Do not run container as root\n"
        dockerfileUserPart += "# for now: same UID/GID as current user (otherwise no gui because of xhost)\n"
        dockerfileUserPart += "RUN\texport uid=1001 gid=1001" + continueRUN
        dockerfileUserPart += "\tgroupadd --system --gid ${gid} " + self.userName + continueRUN
        dockerfileUserPart += "\tuseradd  --system --gid ${gid} --groups audio,video --uid ${uid} " + self.userName + continueRUN
        dockerfileUserPart += "\tmkdir -p /home/" + self.userName + continueRUN
        dockerfileUserPart += "\tchown -R ${uid}:${gid} /home/" + self.userName + "\n"
        return dockerfileUserPart